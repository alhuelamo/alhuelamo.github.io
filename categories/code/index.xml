<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>code on Alberto Huélamo</title><link>https://alhuelamo.com/categories/code/</link><description>Recent content in code on Alberto Huélamo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 15 Feb 2024 16:30:00 +0100</lastBuildDate><atom:link href="https://alhuelamo.com/categories/code/index.xml" rel="self" type="application/rss+xml"/><item><title>The 'indirect' argument in pytest fixture parametrization</title><link>https://alhuelamo.com/posts/2024/02/the-indirect-argument-in-pytest-fixture-parametrization/</link><pubDate>Thu, 15 Feb 2024 16:30:00 +0100</pubDate><guid>https://alhuelamo.com/posts/2024/02/the-indirect-argument-in-pytest-fixture-parametrization/</guid><description>Photo by Julia Koblitz in Unsplash
The purpose of indirect=True in the pytest.mark.parametrize decorator was not very clear to me just by reading pytest documentation:
Using the indirect=True parameter when parametrizing a test allows to parametrize a test with a fixture receiving the values before passing them to a test
import pytest @pytest.fixture def fixt(request): return request.param * 3 @pytest.mark.parametrize(&amp;#34;fixt&amp;#34;, [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;], indirect=True) def test_indirect(fixt): assert len(fixt) == 3 I found this definition rather unclear, and a bit of a mouthful.</description></item><item><title>Monadic Resource Management in Scala</title><link>https://alhuelamo.com/posts/2022/02/monadic-resource-management-in-scala/</link><pubDate>Mon, 14 Feb 2022 16:30:00 +0100</pubDate><guid>https://alhuelamo.com/posts/2022/02/monadic-resource-management-in-scala/</guid><description>Photo by Markus Spiske in Unsplash
In my company we have a considerably big Scala codebase. We use Scala for data pipelines, function apps, web services&amp;hellip; Everything is based on a common set of libraries that standardizes access to resources, enforces some conventions, and of course provides several utilities. One of this is a tiny little method which implements automatic context/resource management for AutoCloseable objects.
def withCloseable[C &amp;lt;: AutoCloseable, R](closeable: =&amp;gt; C)(f: C =&amp;gt; R): R = { // simplified implementation val result = f(closeable) closeable.</description></item></channel></rss>