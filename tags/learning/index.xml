<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>learning on Alberto Huélamo</title><link>https://alhuelamo.com/tags/learning/</link><description>Recent content in learning on Alberto Huélamo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Mon, 14 Feb 2022 16:30:00 +0100</lastBuildDate><atom:link href="https://alhuelamo.com/tags/learning/index.xml" rel="self" type="application/rss+xml"/><item><title>Monadic Resource Management in Scala</title><link>https://alhuelamo.com/posts/2022/02/monadic-resource-management-in-scala/</link><pubDate>Mon, 14 Feb 2022 16:30:00 +0100</pubDate><guid>https://alhuelamo.com/posts/2022/02/monadic-resource-management-in-scala/</guid><description>Photo by Markus Spiske in Unsplash
In my company we have a considerably big Scala codebase. We use Scala for data pipelines, function apps, web services&amp;hellip; Everything is based on a common set of libraries that standardizes access to resources, enforces some conventions, and of course provides several utilities. One of this is a tiny little method which implements automatic context/resource management for AutoCloseable objects.
def withCloseable[C &amp;lt;: AutoCloseable, R](closeable: =&amp;gt; C)(f: C =&amp;gt; R): R = { // simplified implementation val result = f(closeable) closeable.</description></item></channel></rss>